// Code generated by protoc-gen-go.
// source: scheduler.proto
// DO NOT EDIT!

package qpov

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LoginRequest struct {
	Cookie string `protobuf:"bytes,1,opt,name=cookie" json:"cookie,omitempty"`
	Jwt    string `protobuf:"bytes,2,opt,name=jwt" json:"jwt,omitempty"`
}

func (m *LoginRequest) Reset()                    { *m = LoginRequest{} }
func (m *LoginRequest) String() string            { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()               {}
func (*LoginRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type LoginReply struct {
	Cookie string `protobuf:"bytes,1,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *LoginReply) Reset()                    { *m = LoginReply{} }
func (m *LoginReply) String() string            { return proto.CompactTextString(m) }
func (*LoginReply) ProtoMessage()               {}
func (*LoginReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

type LogoutRequest struct {
	Cookie string `protobuf:"bytes,1,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *LogoutRequest) Reset()                    { *m = LogoutRequest{} }
func (m *LogoutRequest) String() string            { return proto.CompactTextString(m) }
func (*LogoutRequest) ProtoMessage()               {}
func (*LogoutRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

type LogoutReply struct {
}

func (m *LogoutReply) Reset()                    { *m = LogoutReply{} }
func (m *LogoutReply) String() string            { return proto.CompactTextString(m) }
func (*LogoutReply) ProtoMessage()               {}
func (*LogoutReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

type CheckCookieRequest struct {
	Cookie string `protobuf:"bytes,1,opt,name=cookie" json:"cookie,omitempty"`
}

func (m *CheckCookieRequest) Reset()                    { *m = CheckCookieRequest{} }
func (m *CheckCookieRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckCookieRequest) ProtoMessage()               {}
func (*CheckCookieRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

type CheckCookieReply struct {
}

func (m *CheckCookieReply) Reset()                    { *m = CheckCookieReply{} }
func (m *CheckCookieReply) String() string            { return proto.CompactTextString(m) }
func (*CheckCookieReply) ProtoMessage()               {}
func (*CheckCookieReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

type CertificateRequest struct {
}

func (m *CertificateRequest) Reset()                    { *m = CertificateRequest{} }
func (m *CertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*CertificateRequest) ProtoMessage()               {}
func (*CertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

type CertificateReply struct {
	Pem []byte `protobuf:"bytes,1,opt,name=pem,proto3" json:"pem,omitempty"`
}

func (m *CertificateReply) Reset()                    { *m = CertificateReply{} }
func (m *CertificateReply) String() string            { return proto.CompactTextString(m) }
func (*CertificateReply) ProtoMessage()               {}
func (*CertificateReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

type GetRequest struct {
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

type GetReply struct {
	LeaseId         string `protobuf:"bytes,1,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
	OrderDefinition string `protobuf:"bytes,2,opt,name=order_definition,json=orderDefinition" json:"order_definition,omitempty"`
}

func (m *GetReply) Reset()                    { *m = GetReply{} }
func (m *GetReply) String() string            { return proto.CompactTextString(m) }
func (*GetReply) ProtoMessage()               {}
func (*GetReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

type RenewRequest struct {
	LeaseId   string `protobuf:"bytes,1,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
	ExtendSec int32  `protobuf:"varint,2,opt,name=extend_sec,json=extendSec" json:"extend_sec,omitempty"`
}

func (m *RenewRequest) Reset()                    { *m = RenewRequest{} }
func (m *RenewRequest) String() string            { return proto.CompactTextString(m) }
func (*RenewRequest) ProtoMessage()               {}
func (*RenewRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

type RenewReply struct {
	NewTimeoutSec int64 `protobuf:"varint,1,opt,name=new_timeout_sec,json=newTimeoutSec" json:"new_timeout_sec,omitempty"`
}

func (m *RenewReply) Reset()                    { *m = RenewReply{} }
func (m *RenewReply) String() string            { return proto.CompactTextString(m) }
func (*RenewReply) ProtoMessage()               {}
func (*RenewReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

type DoneRequest struct {
	LeaseId      string             `protobuf:"bytes,1,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
	Image        []byte             `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	Stdout       []byte             `protobuf:"bytes,3,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr       []byte             `protobuf:"bytes,4,opt,name=stderr,proto3" json:"stderr,omitempty"`
	JsonMetadata string             `protobuf:"bytes,5,opt,name=json_metadata,json=jsonMetadata" json:"json_metadata,omitempty"`
	Metadata     *RenderingMetadata `protobuf:"bytes,6,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *DoneRequest) Reset()                    { *m = DoneRequest{} }
func (m *DoneRequest) String() string            { return proto.CompactTextString(m) }
func (*DoneRequest) ProtoMessage()               {}
func (*DoneRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *DoneRequest) GetMetadata() *RenderingMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type DoneReply struct {
}

func (m *DoneReply) Reset()                    { *m = DoneReply{} }
func (m *DoneReply) String() string            { return proto.CompactTextString(m) }
func (*DoneReply) ProtoMessage()               {}
func (*DoneReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

type FailedRequest struct {
	LeaseId string `protobuf:"bytes,1,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
}

func (m *FailedRequest) Reset()                    { *m = FailedRequest{} }
func (m *FailedRequest) String() string            { return proto.CompactTextString(m) }
func (*FailedRequest) ProtoMessage()               {}
func (*FailedRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{14} }

type FailedReply struct {
}

func (m *FailedReply) Reset()                    { *m = FailedReply{} }
func (m *FailedReply) String() string            { return proto.CompactTextString(m) }
func (*FailedReply) ProtoMessage()               {}
func (*FailedReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{15} }

type AddRequest struct {
	OrderDefinition string `protobuf:"bytes,1,opt,name=order_definition,json=orderDefinition" json:"order_definition,omitempty"`
}

func (m *AddRequest) Reset()                    { *m = AddRequest{} }
func (m *AddRequest) String() string            { return proto.CompactTextString(m) }
func (*AddRequest) ProtoMessage()               {}
func (*AddRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{16} }

type AddReply struct {
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
}

func (m *AddReply) Reset()                    { *m = AddReply{} }
func (m *AddReply) String() string            { return proto.CompactTextString(m) }
func (*AddReply) ProtoMessage()               {}
func (*AddReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{17} }

type Lease struct {
	OrderId   string             `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	LeaseId   string             `protobuf:"bytes,2,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
	Done      bool               `protobuf:"varint,3,opt,name=done" json:"done,omitempty"`
	UserId    int64              `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	CreatedMs int64              `protobuf:"varint,5,opt,name=created_ms,json=createdMs" json:"created_ms,omitempty"`
	UpdatedMs int64              `protobuf:"varint,6,opt,name=updated_ms,json=updatedMs" json:"updated_ms,omitempty"`
	ExpiresMs int64              `protobuf:"varint,7,opt,name=expires_ms,json=expiresMs" json:"expires_ms,omitempty"`
	Order     *Order             `protobuf:"bytes,8,opt,name=order" json:"order,omitempty"`
	Metadata  *RenderingMetadata `protobuf:"bytes,9,opt,name=metadata" json:"metadata,omitempty"`
	Failed    bool               `protobuf:"varint,10,opt,name=failed" json:"failed,omitempty"`
	Address   string             `protobuf:"bytes,11,opt,name=address" json:"address,omitempty"`
	Hostname  string             `protobuf:"bytes,12,opt,name=hostname" json:"hostname,omitempty"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (m *Lease) String() string            { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{18} }

func (m *Lease) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Lease) GetMetadata() *RenderingMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type LeaseRequest struct {
	LeaseId string `protobuf:"bytes,1,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
}

func (m *LeaseRequest) Reset()                    { *m = LeaseRequest{} }
func (m *LeaseRequest) String() string            { return proto.CompactTextString(m) }
func (*LeaseRequest) ProtoMessage()               {}
func (*LeaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{19} }

type LeaseReply struct {
	Lease *Lease `protobuf:"bytes,1,opt,name=lease" json:"lease,omitempty"`
}

func (m *LeaseReply) Reset()                    { *m = LeaseReply{} }
func (m *LeaseReply) String() string            { return proto.CompactTextString(m) }
func (*LeaseReply) ProtoMessage()               {}
func (*LeaseReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{20} }

func (m *LeaseReply) GetLease() *Lease {
	if m != nil {
		return m.Lease
	}
	return nil
}

type LeasesRequest struct {
	Done     bool `protobuf:"varint,1,opt,name=done" json:"done,omitempty"`
	Order    bool `protobuf:"varint,2,opt,name=order" json:"order,omitempty"`
	Metadata bool `protobuf:"varint,3,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *LeasesRequest) Reset()                    { *m = LeasesRequest{} }
func (m *LeasesRequest) String() string            { return proto.CompactTextString(m) }
func (*LeasesRequest) ProtoMessage()               {}
func (*LeasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{21} }

type LeasesReply struct {
	Lease *Lease `protobuf:"bytes,1,opt,name=lease" json:"lease,omitempty"`
}

func (m *LeasesReply) Reset()                    { *m = LeasesReply{} }
func (m *LeasesReply) String() string            { return proto.CompactTextString(m) }
func (*LeasesReply) ProtoMessage()               {}
func (*LeasesReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{22} }

func (m *LeasesReply) GetLease() *Lease {
	if m != nil {
		return m.Lease
	}
	return nil
}

type OrdersRequest struct {
	Done      bool `protobuf:"varint,1,opt,name=done" json:"done,omitempty"`
	Active    bool `protobuf:"varint,2,opt,name=active" json:"active,omitempty"`
	Unstarted bool `protobuf:"varint,3,opt,name=unstarted" json:"unstarted,omitempty"`
}

func (m *OrdersRequest) Reset()                    { *m = OrdersRequest{} }
func (m *OrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*OrdersRequest) ProtoMessage()               {}
func (*OrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{23} }

type OrderStat struct {
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId" json:"order_id,omitempty"`
	Done    bool   `protobuf:"varint,2,opt,name=done" json:"done,omitempty"`
	Active  bool   `protobuf:"varint,3,opt,name=active" json:"active,omitempty"`
}

func (m *OrderStat) Reset()                    { *m = OrderStat{} }
func (m *OrderStat) String() string            { return proto.CompactTextString(m) }
func (*OrderStat) ProtoMessage()               {}
func (*OrderStat) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{24} }

type OrdersReply struct {
	Order *OrderStat `protobuf:"bytes,1,opt,name=order" json:"order,omitempty"`
}

func (m *OrdersReply) Reset()                    { *m = OrdersReply{} }
func (m *OrdersReply) String() string            { return proto.CompactTextString(m) }
func (*OrdersReply) ProtoMessage()               {}
func (*OrdersReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{25} }

func (m *OrdersReply) GetOrder() *OrderStat {
	if m != nil {
		return m.Order
	}
	return nil
}

type SchedulingStats struct {
	Orders       int64 `protobuf:"varint,1,opt,name=orders" json:"orders,omitempty"`
	ActiveOrders int64 `protobuf:"varint,2,opt,name=active_orders,json=activeOrders" json:"active_orders,omitempty"`
	DoneOrders   int64 `protobuf:"varint,3,opt,name=done_orders,json=doneOrders" json:"done_orders,omitempty"`
	Leases       int64 `protobuf:"varint,4,opt,name=leases" json:"leases,omitempty"`
	ActiveLeases int64 `protobuf:"varint,5,opt,name=active_leases,json=activeLeases" json:"active_leases,omitempty"`
	DoneLeases   int64 `protobuf:"varint,6,opt,name=done_leases,json=doneLeases" json:"done_leases,omitempty"`
}

func (m *SchedulingStats) Reset()                    { *m = SchedulingStats{} }
func (m *SchedulingStats) String() string            { return proto.CompactTextString(m) }
func (*SchedulingStats) ProtoMessage()               {}
func (*SchedulingStats) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{26} }

type StatsRequest struct {
	SchedulingStats bool `protobuf:"varint,1,opt,name=scheduling_stats,json=schedulingStats" json:"scheduling_stats,omitempty"`
}

func (m *StatsRequest) Reset()                    { *m = StatsRequest{} }
func (m *StatsRequest) String() string            { return proto.CompactTextString(m) }
func (*StatsRequest) ProtoMessage()               {}
func (*StatsRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{27} }

// Global stats.
type StatsReply struct {
	SchedulingStats *SchedulingStats `protobuf:"bytes,1,opt,name=scheduling_stats,json=schedulingStats" json:"scheduling_stats,omitempty"`
}

func (m *StatsReply) Reset()                    { *m = StatsReply{} }
func (m *StatsReply) String() string            { return proto.CompactTextString(m) }
func (*StatsReply) ProtoMessage()               {}
func (*StatsReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{28} }

func (m *StatsReply) GetSchedulingStats() *SchedulingStats {
	if m != nil {
		return m.SchedulingStats
	}
	return nil
}

type ResultRequest struct {
	LeaseId string `protobuf:"bytes,1,opt,name=lease_id,json=leaseId" json:"lease_id,omitempty"`
	Data    bool   `protobuf:"varint,2,opt,name=data" json:"data,omitempty"`
}

func (m *ResultRequest) Reset()                    { *m = ResultRequest{} }
func (m *ResultRequest) String() string            { return proto.CompactTextString(m) }
func (*ResultRequest) ProtoMessage()               {}
func (*ResultRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{29} }

type ResultReply struct {
	ContentType string `protobuf:"bytes,1,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	Data        []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ResultReply) Reset()                    { *m = ResultReply{} }
func (m *ResultReply) String() string            { return proto.CompactTextString(m) }
func (*ResultReply) ProtoMessage()               {}
func (*ResultReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{30} }

func init() {
	proto.RegisterType((*LoginRequest)(nil), "qpov.LoginRequest")
	proto.RegisterType((*LoginReply)(nil), "qpov.LoginReply")
	proto.RegisterType((*LogoutRequest)(nil), "qpov.LogoutRequest")
	proto.RegisterType((*LogoutReply)(nil), "qpov.LogoutReply")
	proto.RegisterType((*CheckCookieRequest)(nil), "qpov.CheckCookieRequest")
	proto.RegisterType((*CheckCookieReply)(nil), "qpov.CheckCookieReply")
	proto.RegisterType((*CertificateRequest)(nil), "qpov.CertificateRequest")
	proto.RegisterType((*CertificateReply)(nil), "qpov.CertificateReply")
	proto.RegisterType((*GetRequest)(nil), "qpov.GetRequest")
	proto.RegisterType((*GetReply)(nil), "qpov.GetReply")
	proto.RegisterType((*RenewRequest)(nil), "qpov.RenewRequest")
	proto.RegisterType((*RenewReply)(nil), "qpov.RenewReply")
	proto.RegisterType((*DoneRequest)(nil), "qpov.DoneRequest")
	proto.RegisterType((*DoneReply)(nil), "qpov.DoneReply")
	proto.RegisterType((*FailedRequest)(nil), "qpov.FailedRequest")
	proto.RegisterType((*FailedReply)(nil), "qpov.FailedReply")
	proto.RegisterType((*AddRequest)(nil), "qpov.AddRequest")
	proto.RegisterType((*AddReply)(nil), "qpov.AddReply")
	proto.RegisterType((*Lease)(nil), "qpov.Lease")
	proto.RegisterType((*LeaseRequest)(nil), "qpov.LeaseRequest")
	proto.RegisterType((*LeaseReply)(nil), "qpov.LeaseReply")
	proto.RegisterType((*LeasesRequest)(nil), "qpov.LeasesRequest")
	proto.RegisterType((*LeasesReply)(nil), "qpov.LeasesReply")
	proto.RegisterType((*OrdersRequest)(nil), "qpov.OrdersRequest")
	proto.RegisterType((*OrderStat)(nil), "qpov.OrderStat")
	proto.RegisterType((*OrdersReply)(nil), "qpov.OrdersReply")
	proto.RegisterType((*SchedulingStats)(nil), "qpov.SchedulingStats")
	proto.RegisterType((*StatsRequest)(nil), "qpov.StatsRequest")
	proto.RegisterType((*StatsReply)(nil), "qpov.StatsReply")
	proto.RegisterType((*ResultRequest)(nil), "qpov.ResultRequest")
	proto.RegisterType((*ResultReply)(nil), "qpov.ResultReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for CookieMonster service

type CookieMonsterClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutReply, error)
	CheckCookie(ctx context.Context, in *CheckCookieRequest, opts ...grpc.CallOption) (*CheckCookieReply, error)
}

type cookieMonsterClient struct {
	cc *grpc.ClientConn
}

func NewCookieMonsterClient(cc *grpc.ClientConn) CookieMonsterClient {
	return &cookieMonsterClient{cc}
}

func (c *cookieMonsterClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error) {
	out := new(LoginReply)
	err := grpc.Invoke(ctx, "/qpov.CookieMonster/Login", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cookieMonsterClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutReply, error) {
	out := new(LogoutReply)
	err := grpc.Invoke(ctx, "/qpov.CookieMonster/Logout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cookieMonsterClient) CheckCookie(ctx context.Context, in *CheckCookieRequest, opts ...grpc.CallOption) (*CheckCookieReply, error) {
	out := new(CheckCookieReply)
	err := grpc.Invoke(ctx, "/qpov.CookieMonster/CheckCookie", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CookieMonster service

type CookieMonsterServer interface {
	Login(context.Context, *LoginRequest) (*LoginReply, error)
	Logout(context.Context, *LogoutRequest) (*LogoutReply, error)
	CheckCookie(context.Context, *CheckCookieRequest) (*CheckCookieReply, error)
}

func RegisterCookieMonsterServer(s *grpc.Server, srv CookieMonsterServer) {
	s.RegisterService(&_CookieMonster_serviceDesc, srv)
}

func _CookieMonster_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CookieMonsterServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.CookieMonster/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CookieMonsterServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CookieMonster_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CookieMonsterServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.CookieMonster/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CookieMonsterServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CookieMonster_CheckCookie_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCookieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CookieMonsterServer).CheckCookie(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.CookieMonster/CheckCookie",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CookieMonsterServer).CheckCookie(ctx, req.(*CheckCookieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CookieMonster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qpov.CookieMonster",
	HandlerType: (*CookieMonsterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _CookieMonster_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _CookieMonster_Logout_Handler,
		},
		{
			MethodName: "CheckCookie",
			Handler:    _CookieMonster_CheckCookie_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Scheduler service

type SchedulerClient interface {
	// Render client API.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetReply, error)
	Renew(ctx context.Context, in *RenewRequest, opts ...grpc.CallOption) (*RenewReply, error)
	Done(ctx context.Context, in *DoneRequest, opts ...grpc.CallOption) (*DoneReply, error)
	Failed(ctx context.Context, in *FailedRequest, opts ...grpc.CallOption) (*FailedReply, error)
	// Order handling API. Restricted.
	Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddReply, error)
	// Stats API. Restricted.
	Lease(ctx context.Context, in *LeaseRequest, opts ...grpc.CallOption) (*LeaseReply, error)
	Leases(ctx context.Context, in *LeasesRequest, opts ...grpc.CallOption) (Scheduler_LeasesClient, error)
	Orders(ctx context.Context, in *OrdersRequest, opts ...grpc.CallOption) (Scheduler_OrdersClient, error)
	Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error)
	// WebUI magic.
	// rpc UserStats (UserStatsRequest) returns (UserStatsReply) {}
	Result(ctx context.Context, in *ResultRequest, opts ...grpc.CallOption) (Scheduler_ResultClient, error)
	Certificate(ctx context.Context, in *CertificateRequest, opts ...grpc.CallOption) (*CertificateReply, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetReply, error) {
	out := new(GetReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Renew(ctx context.Context, in *RenewRequest, opts ...grpc.CallOption) (*RenewReply, error) {
	out := new(RenewReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Renew", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Done(ctx context.Context, in *DoneRequest, opts ...grpc.CallOption) (*DoneReply, error) {
	out := new(DoneReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Done", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Failed(ctx context.Context, in *FailedRequest, opts ...grpc.CallOption) (*FailedReply, error) {
	out := new(FailedReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Failed", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*AddReply, error) {
	out := new(AddReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Lease(ctx context.Context, in *LeaseRequest, opts ...grpc.CallOption) (*LeaseReply, error) {
	out := new(LeaseReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Lease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Leases(ctx context.Context, in *LeasesRequest, opts ...grpc.CallOption) (Scheduler_LeasesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[0], c.cc, "/qpov.Scheduler/Leases", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerLeasesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_LeasesClient interface {
	Recv() (*LeasesReply, error)
	grpc.ClientStream
}

type schedulerLeasesClient struct {
	grpc.ClientStream
}

func (x *schedulerLeasesClient) Recv() (*LeasesReply, error) {
	m := new(LeasesReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) Orders(ctx context.Context, in *OrdersRequest, opts ...grpc.CallOption) (Scheduler_OrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[1], c.cc, "/qpov.Scheduler/Orders", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_OrdersClient interface {
	Recv() (*OrdersReply, error)
	grpc.ClientStream
}

type schedulerOrdersClient struct {
	grpc.ClientStream
}

func (x *schedulerOrdersClient) Recv() (*OrdersReply, error) {
	m := new(OrdersReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error) {
	out := new(StatsReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Stats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Result(ctx context.Context, in *ResultRequest, opts ...grpc.CallOption) (Scheduler_ResultClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[2], c.cc, "/qpov.Scheduler/Result", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerResultClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_ResultClient interface {
	Recv() (*ResultReply, error)
	grpc.ClientStream
}

type schedulerResultClient struct {
	grpc.ClientStream
}

func (x *schedulerResultClient) Recv() (*ResultReply, error) {
	m := new(ResultReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) Certificate(ctx context.Context, in *CertificateRequest, opts ...grpc.CallOption) (*CertificateReply, error) {
	out := new(CertificateReply)
	err := grpc.Invoke(ctx, "/qpov.Scheduler/Certificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Scheduler service

type SchedulerServer interface {
	// Render client API.
	Get(context.Context, *GetRequest) (*GetReply, error)
	Renew(context.Context, *RenewRequest) (*RenewReply, error)
	Done(context.Context, *DoneRequest) (*DoneReply, error)
	Failed(context.Context, *FailedRequest) (*FailedReply, error)
	// Order handling API. Restricted.
	Add(context.Context, *AddRequest) (*AddReply, error)
	// Stats API. Restricted.
	Lease(context.Context, *LeaseRequest) (*LeaseReply, error)
	Leases(*LeasesRequest, Scheduler_LeasesServer) error
	Orders(*OrdersRequest, Scheduler_OrdersServer) error
	Stats(context.Context, *StatsRequest) (*StatsReply, error)
	// WebUI magic.
	// rpc UserStats (UserStatsRequest) returns (UserStatsReply) {}
	Result(*ResultRequest, Scheduler_ResultServer) error
	Certificate(context.Context, *CertificateRequest) (*CertificateReply, error)
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Renew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Renew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Renew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Renew(ctx, req.(*RenewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Done_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Done(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Done",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Done(ctx, req.(*DoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Failed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Failed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Failed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Failed(ctx, req.(*FailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Add(ctx, req.(*AddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Lease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Lease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Lease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Lease(ctx, req.(*LeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Leases_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LeasesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).Leases(m, &schedulerLeasesServer{stream})
}

type Scheduler_LeasesServer interface {
	Send(*LeasesReply) error
	grpc.ServerStream
}

type schedulerLeasesServer struct {
	grpc.ServerStream
}

func (x *schedulerLeasesServer) Send(m *LeasesReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_Orders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).Orders(m, &schedulerOrdersServer{stream})
}

type Scheduler_OrdersServer interface {
	Send(*OrdersReply) error
	grpc.ServerStream
}

type schedulerOrdersServer struct {
	grpc.ServerStream
}

func (x *schedulerOrdersServer) Send(m *OrdersReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Stats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Stats(ctx, req.(*StatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Result_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ResultRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).Result(m, &schedulerResultServer{stream})
}

type Scheduler_ResultServer interface {
	Send(*ResultReply) error
	grpc.ServerStream
}

type schedulerResultServer struct {
	grpc.ServerStream
}

func (x *schedulerResultServer) Send(m *ResultReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_Certificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).Certificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qpov.Scheduler/Certificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).Certificate(ctx, req.(*CertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qpov.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Scheduler_Get_Handler,
		},
		{
			MethodName: "Renew",
			Handler:    _Scheduler_Renew_Handler,
		},
		{
			MethodName: "Done",
			Handler:    _Scheduler_Done_Handler,
		},
		{
			MethodName: "Failed",
			Handler:    _Scheduler_Failed_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _Scheduler_Add_Handler,
		},
		{
			MethodName: "Lease",
			Handler:    _Scheduler_Lease_Handler,
		},
		{
			MethodName: "Stats",
			Handler:    _Scheduler_Stats_Handler,
		},
		{
			MethodName: "Certificate",
			Handler:    _Scheduler_Certificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Leases",
			Handler:       _Scheduler_Leases_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Orders",
			Handler:       _Scheduler_Orders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Result",
			Handler:       _Scheduler_Result_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor2 = []byte{
	// 1109 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x56, 0x5b, 0x73, 0xdb, 0x44,
	0x14, 0x8e, 0xaf, 0xb1, 0x8f, 0xe4, 0x3a, 0x6c, 0x42, 0x2b, 0x3c, 0x30, 0x80, 0xa0, 0x40, 0x99,
	0x4e, 0xda, 0x49, 0x3b, 0x03, 0xbc, 0x30, 0x74, 0x9a, 0xe1, 0x32, 0xd3, 0x00, 0xa3, 0x94, 0x07,
	0x9e, 0x3c, 0xc2, 0xda, 0x24, 0x6a, 0x63, 0xc9, 0xf5, 0xae, 0x7b, 0xf9, 0x65, 0x3c, 0xf0, 0x07,
	0x78, 0xe1, 0xa7, 0xf0, 0x1f, 0x7a, 0xce, 0x9e, 0x5d, 0x69, 0xe5, 0xa4, 0x89, 0xdf, 0x74, 0xbe,
	0x73, 0xbf, 0xe8, 0x9c, 0x85, 0xb1, 0x9a, 0x9d, 0xc9, 0x6c, 0x75, 0x2e, 0x97, 0xfb, 0x8b, 0x65,
	0xa9, 0x4b, 0xd1, 0x7d, 0xb1, 0x28, 0x5f, 0x4e, 0x82, 0x72, 0x99, 0x39, 0x68, 0x72, 0x63, 0x2e,
	0x75, 0x9a, 0xa5, 0x3a, 0x65, 0x3a, 0xfe, 0x16, 0xc2, 0x27, 0xe5, 0x69, 0x5e, 0x24, 0xf2, 0xc5,
	0x4a, 0x2a, 0x2d, 0x6e, 0x42, 0x7f, 0x56, 0x96, 0xcf, 0x73, 0x19, 0xb5, 0x3e, 0x69, 0x7d, 0x35,
	0x4c, 0x2c, 0x25, 0x76, 0xa0, 0xf3, 0xec, 0x95, 0x8e, 0xda, 0x06, 0xa4, 0xcf, 0xf8, 0x73, 0x00,
	0xab, 0xb9, 0x38, 0x7f, 0xf3, 0x2e, 0xbd, 0xf8, 0x4b, 0x18, 0xa1, 0x54, 0xb9, 0xd2, 0xd7, 0x38,
	0x88, 0x47, 0x10, 0x38, 0x41, 0xb4, 0x17, 0xdf, 0x05, 0xf1, 0xf8, 0x4c, 0xce, 0x9e, 0x3f, 0x36,
	0xdc, 0xeb, 0x94, 0x05, 0xec, 0x34, 0xa4, 0xc9, 0xc2, 0x1e, 0x5a, 0x90, 0x4b, 0x9d, 0x9f, 0xe4,
	0xb3, 0x54, 0x3b, 0x0b, 0x18, 0xf5, 0x4e, 0x03, 0xa5, 0xd8, 0x31, 0xb7, 0x85, 0x9c, 0x1b, 0x93,
	0x61, 0x42, 0x9f, 0x71, 0x08, 0xf0, 0x93, 0x74, 0x21, 0xc7, 0xbf, 0xc3, 0xc0, 0x50, 0x24, 0xfb,
	0x01, 0x0c, 0xce, 0x65, 0xaa, 0xe4, 0x34, 0xcf, 0x6c, 0x0c, 0xdb, 0x86, 0xfe, 0x25, 0x13, 0x77,
	0x60, 0xc7, 0x54, 0x7a, 0x9a, 0xc9, 0x93, 0xbc, 0xc8, 0x75, 0x5e, 0x16, 0xb6, 0x5e, 0x63, 0x83,
	0x1f, 0x56, 0x70, 0xfc, 0x33, 0x84, 0x89, 0x2c, 0xe4, 0x2b, 0x97, 0xd7, 0x15, 0x56, 0x3f, 0x02,
	0x90, 0xaf, 0xb5, 0x2c, 0xb2, 0xa9, 0x92, 0x33, 0x63, 0xaf, 0x97, 0x0c, 0x19, 0x39, 0x96, 0xb3,
	0xf8, 0x21, 0x80, 0xb5, 0x44, 0xd1, 0x7d, 0x01, 0x63, 0xfc, 0x9e, 0xea, 0x7c, 0x2e, 0xb1, 0x92,
	0x46, 0x83, 0xcc, 0x75, 0x92, 0x11, 0xc2, 0x4f, 0x19, 0x25, 0xad, 0x7f, 0x5b, 0x10, 0x1c, 0x96,
	0x85, 0xdc, 0xc0, 0xff, 0x1e, 0xf4, 0xf2, 0x79, 0x7a, 0x2a, 0x8d, 0xeb, 0x30, 0x61, 0x82, 0x1a,
	0xa1, 0x74, 0x86, 0xd6, 0xa2, 0x8e, 0x81, 0x2d, 0x65, 0x71, 0xb9, 0x5c, 0x46, 0xdd, 0x0a, 0x47,
	0x4a, 0x7c, 0x06, 0xa3, 0x67, 0xaa, 0x2c, 0xa6, 0x6e, 0xfa, 0xa2, 0x9e, 0xf1, 0x12, 0x12, 0x78,
	0x64, 0x31, 0xf1, 0x00, 0x06, 0x15, 0xbf, 0x8f, 0xfc, 0xe0, 0xe0, 0xd6, 0x3e, 0x4d, 0xf0, 0x3e,
	0x66, 0x88, 0x56, 0xf2, 0xe2, 0xd4, 0x89, 0x26, 0x95, 0x60, 0x1c, 0xc0, 0x90, 0x33, 0xa1, 0x9e,
	0x7f, 0x0d, 0xa3, 0x1f, 0xd3, 0xfc, 0x5c, 0x66, 0xd7, 0x27, 0x46, 0x03, 0xe7, 0x64, 0x49, 0xf5,
	0x1b, 0x80, 0x47, 0x59, 0xa5, 0x77, 0x59, 0x2f, 0x5b, 0x97, 0xf7, 0xf2, 0x36, 0x0c, 0x8c, 0xa2,
	0x9d, 0x0e, 0x56, 0xab, 0xdd, 0x19, 0x1a, 0xdd, 0xfd, 0xdf, 0x86, 0xde, 0x13, 0x72, 0x7d, 0x85,
	0x50, 0x23, 0xdc, 0x76, 0xb3, 0x0f, 0x02, 0xba, 0x19, 0xe6, 0x69, 0xea, 0x3d, 0x48, 0xcc, 0xb7,
	0xb8, 0x05, 0xdb, 0x2b, 0xc5, 0x86, 0xba, 0xa6, 0xcd, 0x7d, 0x22, 0x79, 0x68, 0x66, 0x4b, 0x89,
	0x03, 0x9e, 0x4d, 0xe7, 0xca, 0xd4, 0xba, 0x93, 0x0c, 0x2d, 0x72, 0xa4, 0x88, 0xbd, 0x5a, 0x64,
	0x8e, 0xdd, 0x67, 0xb6, 0x45, 0x98, 0x2d, 0x5f, 0x2f, 0xf2, 0xa5, 0x54, 0xc4, 0xde, 0x66, 0xb6,
	0x45, 0x90, 0xfd, 0x29, 0xf4, 0x4c, 0xbc, 0xd1, 0xc0, 0xf4, 0x28, 0xe0, 0x1e, 0xfd, 0x46, 0x50,
	0xc2, 0x9c, 0x46, 0x27, 0x87, 0x1b, 0x76, 0x92, 0x66, 0xe7, 0xc4, 0x34, 0x24, 0x02, 0x93, 0xa3,
	0xa5, 0x44, 0x04, 0xdb, 0x69, 0x96, 0xa1, 0x6f, 0x15, 0x05, 0x5c, 0x13, 0x4b, 0x8a, 0x09, 0x0c,
	0xce, 0x4a, 0xa5, 0x8b, 0x74, 0x2e, 0xa3, 0xd0, 0xb0, 0x2a, 0x3a, 0xbe, 0x83, 0x8b, 0x8d, 0x4a,
	0xb7, 0xc1, 0x24, 0xdc, 0xc3, 0x4d, 0xc6, 0xa2, 0xd4, 0x43, 0x4c, 0xcf, 0x30, 0x8c, 0x54, 0x95,
	0x1e, 0x0b, 0x30, 0x27, 0xfe, 0x03, 0x97, 0x1a, 0x7d, 0x28, 0x67, 0xdc, 0x35, 0xa7, 0xe5, 0x35,
	0x67, 0xcf, 0x95, 0xa9, 0x6d, 0x40, 0x5b, 0x99, 0x89, 0x57, 0x19, 0x6e, 0x65, 0x3d, 0xca, 0xf7,
	0x71, 0x05, 0x5a, 0xb3, 0x1b, 0x06, 0xf2, 0x27, 0x8c, 0x4c, 0xdd, 0xaf, 0x0c, 0x04, 0xeb, 0x9a,
	0xce, 0x74, 0xfe, 0x52, 0xda, 0x48, 0x2c, 0x25, 0x3e, 0x84, 0xe1, 0xaa, 0x50, 0x3a, 0x5d, 0x62,
	0xd7, 0x6d, 0x2c, 0x35, 0x10, 0x27, 0x30, 0x34, 0xa6, 0x8f, 0x75, 0xaa, 0xaf, 0x1a, 0x59, 0xe7,
	0xb1, 0x7d, 0xa9, 0xc7, 0x8e, 0xef, 0x11, 0x97, 0x55, 0xe0, 0xc2, 0xa5, 0x04, 0x6f, 0xbb, 0x0a,
	0x71, 0x82, 0x63, 0x6f, 0x90, 0xc8, 0xab, 0x2d, 0x59, 0xfc, 0x5f, 0x0b, 0xc6, 0xc7, 0x7c, 0xd9,
	0x70, 0x70, 0x88, 0xa3, 0xc8, 0x83, 0x61, 0x2a, 0xbb, 0xdf, 0x2c, 0x45, 0x7b, 0x86, 0x7d, 0x4d,
	0x2d, 0xbb, 0x6d, 0xd8, 0x21, 0x83, 0xec, 0x5c, 0x7c, 0x0c, 0x01, 0x85, 0xe9, 0x44, 0x3a, 0x46,
	0x04, 0x08, 0xb2, 0x02, 0x68, 0xdd, 0xd4, 0x57, 0xb9, 0xdf, 0x8a, 0x29, 0xcf, 0xba, 0x65, 0xf7,
	0x7c, 0xeb, 0xdc, 0xbb, 0xca, 0xba, 0x15, 0xe9, 0xd7, 0xd6, 0x59, 0x20, 0xfe, 0x0e, 0x42, 0x93,
	0x84, 0xb7, 0x6b, 0x54, 0x95, 0xde, 0x54, 0x11, 0xcb, 0xf6, 0x6f, 0xac, 0x9a, 0x69, 0xc7, 0xbf,
	0x02, 0x58, 0x55, 0xaa, 0xdf, 0x0f, 0xef, 0x50, 0x0c, 0x0e, 0xde, 0xe7, 0x52, 0xae, 0x55, 0xed,
	0xa2, 0xbd, 0xef, 0x61, 0x94, 0x48, 0xb5, 0x3a, 0xd7, 0x1b, 0x1c, 0x02, 0x6a, 0x34, 0x4d, 0xad,
	0x6b, 0x34, 0x4d, 0xec, 0x21, 0x04, 0x4e, 0x9f, 0x27, 0x36, 0x9c, 0x95, 0x05, 0x9e, 0x26, 0x3d,
	0xd5, 0x6f, 0x16, 0xee, 0x48, 0x07, 0x16, 0x7b, 0x8a, 0x50, 0xc3, 0x4a, 0xc8, 0x56, 0x0e, 0xfe,
	0x6e, 0xc1, 0x88, 0x2f, 0xf7, 0x51, 0x89, 0xf3, 0x87, 0x7f, 0xc9, 0x3d, 0xdc, 0x95, 0xf4, 0xb6,
	0x10, 0xc2, 0x0e, 0xbd, 0xf7, 0x44, 0x99, 0xec, 0x34, 0x30, 0xda, 0xdd, 0x5b, 0xe2, 0x00, 0xfa,
	0xfc, 0x7a, 0x10, 0xbb, 0x15, 0xb7, 0x7e, 0x74, 0x4c, 0xde, 0x6b, 0x82, 0xac, 0xf3, 0x08, 0x02,
	0xef, 0xd1, 0x20, 0x22, 0x96, 0xb9, 0xf8, 0xea, 0x98, 0xdc, 0xbc, 0x84, 0x63, 0x4c, 0x1c, 0xfc,
	0xd3, 0x85, 0xe1, 0xb1, 0x7b, 0x74, 0x61, 0x23, 0x3b, 0xf8, 0x4e, 0x10, 0x36, 0xbe, 0xfa, 0x01,
	0x31, 0xb9, 0xe1, 0x21, 0xec, 0x1b, 0x13, 0x34, 0x67, 0xdb, 0x25, 0xe8, 0xbf, 0x06, 0x5c, 0x82,
	0xf5, 0x5d, 0x47, 0x85, 0xbb, 0xd0, 0xa5, 0x33, 0x27, 0x6c, 0x26, 0xde, 0xf1, 0x9e, 0x8c, 0x7d,
	0xa8, 0x2a, 0x07, 0xdf, 0x36, 0x57, 0x8e, 0xc6, 0x55, 0x74, 0xe5, 0xf0, 0xcf, 0xdf, 0x16, 0x45,
	0x8f, 0x77, 0xcc, 0x45, 0x5f, 0xdf, 0x42, 0x17, 0xbd, 0x3b, 0x72, 0x1c, 0x3d, 0x9f, 0x32, 0xe1,
	0xef, 0xa4, 0xb5, 0xf6, 0x54, 0x1b, 0x15, 0x15, 0x1e, 0x62, 0x7b, 0xf8, 0xef, 0xd8, 0xf5, 0xb8,
	0x6a, 0xbd, 0x3d, 0xf5, 0xf2, 0x8b, 0xb7, 0xee, 0xb7, 0x48, 0xcb, 0xfe, 0x90, 0xbb, 0xde, 0x6a,
	0x58, 0xd7, 0xf2, 0x36, 0x8a, 0xd1, 0xc2, 0xe0, 0x78, 0x47, 0xd8, 0xe0, 0xfc, 0x7f, 0xcd, 0x05,
	0x57, 0xff, 0x44, 0x1c, 0x1c, 0x0f, 0xb1, 0x73, 0xd3, 0xf8, 0x25, 0x9c, 0x1b, 0x6f, 0xce, 0x8d,
	0x1b, 0x9a, 0x9e, 0xfa, 0x21, 0x59, 0x4d, 0xcf, 0x85, 0x17, 0x67, 0x35, 0x3d, 0x6b, 0xaf, 0xce,
	0x78, 0xeb, 0xaf, 0xbe, 0x79, 0x82, 0x3f, 0x78, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x8d, 0xa7,
	0x34, 0xb8, 0x0b, 0x00, 0x00,
}
